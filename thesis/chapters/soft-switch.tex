\chapter{Software Switch Testing Utility}
\label{switch}
The original plan for testing the tool was to use cheap routers running \textit{OpenWrt}\cite{OpenWrt} with STP enabled.
This did not work for multiple reasons.
\begin{itemize}
    \item \textit{OpenWrt} routers handle the internal switch as one interface, which stops it from disabling single switch ports.
    \item Through testing we found that the packets sent by the \textit{OpenWrt} implementation are not recognized by our other devices.
    The other devices were a \textit{TP-Link TL-SG2008 Gigabit Smart Switch} and an \textit{ASUS RT-N56U Wireless Router}.
    These two devices would just forward the \textit{OpenWrt} STP packets while still sending their own.
    \item We also found that \textit{OpenWrt} just forwards received STP packets, without appending its own data.
    This alone would make it unusable for our purposes.
\end{itemize}

After making these discoveries, we tried \textit{dd-wrt}\cite{dd-wrt} as an alternative.
Unfortunately, it shares the same behaviour with \textit{OpenWrt} and we did not know whether or not we could make either of these operating systems work for this project.

In order to be able to stay withing the time limit while still testing our tool, we decided to implement a bridge capable of STP.
It uses \textit{pcap} to handle incoming packets and react to STP packets.
Our \textit{software-switch} can be run on any number of interfaces, however, it has not been tested on more than two.
The source code for the \textit{software-switch} can be found in its git\cite{software-switch}.
It was written in C, in contrast to the \textit{stp-tree-generator} which was written in C++.

\section{Implementation}
\subsection{Saving Switching Data}
\lstinputlisting[caption=The containers for switching data, label=lst:switchData]{../listings/switch/data.c}
Listing~\ref{lst:switchData} shows the variables and arrays we use for saving the switching data.
The \textit{names}, \textit{neighbours} and \textit{interfaces} arrays are arrays of "strings".
They store the local interface names (as seen in \textit{ifconfig}), the connected MAC addresses and the local MAC addresses respectively.
As basic C does not have strings, these are arrays of \textbf{char} arrays.
In C, arrays are saved as pointers to the first element, with the other elements following sequentially after that.
This makes \textit{names}, \textit{neighbours} and \textit{interfaces} pointers to pointers.
Because the \textit{software-switch} can be run on multiple interfaces we need to keep track of the number of interfaces it is running on, which we do in \textit{n}.
To know which interface to forward a packet on, switches keep a so-called MAC table.
We keep a list of MAC addresses for every interface, making \textit{macTable} an array of arrays of \textbf{char} arrays.
This is due to us saving MAC adrresses as \textbf{char} arrays as well.

The \textit{ifaceMutex} (mutex stands for mutual exclusion) is used to synchronize our different threads.
We use two threads per interface.
One to handle and forward incoming packets, as well as update our STP port states.
The other one sends the STP packets every $helloTime$ seconds.
Sharing memory between \textit{pthreads} (the C thread implementation we used) does not require any setup, as all heap memory is shared\cite{pthreads}.
We need to synchronize these accesses to keep the different threads from corrupting data due to concurrent writes.

\subsection{Handling STP Packets and Port States}
The code that handles STP packets is almost identical to the main tool.
Extraction of the values stays exactly the same, as packets have the same format.
We have to handle this data a lot differently however, the code for which can be seen in Listing~\ref{lst:portStates}.
Parameters prefixed with \textit{r} or \textit{b} are gained from the incoming packet and stand for root and bridge (first hop) respectively.
Values prefixed with \textit{root} are for the root information currently saved in the bridge.
\textit{CurrentIndex} is the index of the interface the packet was received on.
\lstinputlisting[caption=Updating Port States, label=lst:portStates]{../listings/switch/portStates.c}

\subsection{Handling Non STP Packets}
Non STP packets are forwarded based on port states and knowledge of the target MAC address.
We did not implement any special handling for broadcast messages.
None of the packets that the bridge receives should ever come from a broadcast address, which means they should never be contained in the MAC table.
As packets to unknown MAC addresses are broadcast by default, we do not need special behaviour.
\lstinputlisting[caption=Handling non-STP packets, label=lst:nonStp]{../listings/switch/forwarding.c}

\subsection{STP Parameters}
STP parameters like the $helloTime$ and the \textit{forward delay}, as well as priorities can be set on launch.
This is can be done via command line parameters or by using a config file.
If no config file exists in the working directory on launch, the \textit{software-switch} will generate one.
Default parameters are overwritten by any parametrs found in the config file.
These parameters are then in turn overwritten by any command line parameters.
We found this to be the most useful order of precedence for testing.

Any interfaces the tool is to be run on can be passed as well.
%TODO: do something useful with empty space?
